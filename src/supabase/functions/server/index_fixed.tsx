import { Hono } from 'npm:hono'
import { cors } from 'npm:hono/cors'
import { logger } from 'npm:hono/logger'
import { createClient } from 'jsr:@supabase/supabase-js@2'
import * as kv from './kv_store.tsx'

const app = new Hono()

app.use('*', cors({
  origin: '*',
  allowHeaders: ['*'],
  allowMethods: ['*'],
}))

app.use('*', logger(console.log))

const supabase = createClient(
  Deno.env.get('SUPABASE_URL')!,
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!,
)

// Pokemon rarities
const RARITIES = {
  common: { chance: 0.5, color: '#9CA3AF' },
  uncommon: { chance: 0.3, color: '#10B981' },
  rare: { chance: 0.15, color: '#3B82F6' },
  epic: { chance: 0.04, color: '#8B5CF6' },
  legendary: { chance: 0.01, color: '#F59E0B' }
}

// Pack types with customizable settings
const DEFAULT_PACK_TYPES = {
  basic: { 
    name: '–ë–∞–∑–æ–≤—ã–π –ø–∞–∫', 
    cost: 100, 
    cards: 3,
    rarities: {
      common: { enabled: true, chance: 0.6 },
      uncommon: { enabled: true, chance: 0.3 },
      rare: { enabled: true, chance: 0.1 },
      epic: { enabled: false, chance: 0.0 },
      legendary: { enabled: false, chance: 0.0 }
    }
  },
  premium: { 
    name: '–ü—Ä–µ–º–∏—É–º –ø–∞–∫', 
    cost: 250, 
    cards: 5,
    rarities: {
      common: { enabled: true, chance: 0.4 },
      uncommon: { enabled: true, chance: 0.35 },
      rare: { enabled: true, chance: 0.2 },
      epic: { enabled: true, chance: 0.05 },
      legendary: { enabled: false, chance: 0.0 }
    }
  },
  legendary: { 
    name: '–õ–µ–≥–µ–Ω–¥–∞—Ä–Ω—ã–π –ø–∞–∫', 
    cost: 500, 
    cards: 7,
    rarities: {
      common: { enabled: true, chance: 0.2 },
      uncommon: { enabled: true, chance: 0.3 },
      rare: { enabled: true, chance: 0.3 },
      epic: { enabled: true, chance: 0.15 },
      legendary: { enabled: true, chance: 0.05 }
    }
  }
}

// Generate nice user IDs
function generateNiceUserId() {
  const adjectives = ['Red', 'Blue', 'Swift', 'Brave', 'Wild', 'Fire', 'Water', 'Thunder', 'Shadow', 'Mystic', 'Royal', 'Golden', 'Silver', 'Crystal', 'Storm', 'Frost', 'Flame', 'Ocean', 'Forest', 'Sky']
  const animals = ['Pikachu', 'Charizard', 'Blastoise', 'Venusaur', 'Lucario', 'Garchomp', 'Dragonite', 'Mewtwo', 'Mew', 'Rayquaza', 'Dialga', 'Palkia', 'Giratina', 'Arceus', 'Lugia', 'Ho-oh', 'Kyogre', 'Groudon', 'Reshiram', 'Zekrom']
  
  const adj = adjectives[Math.floor(Math.random() * adjectives.length)]
  const animal = animals[Math.floor(Math.random() * animals.length)]
  const number = Math.floor(Math.random() * 9999) + 1
  
  return `${adj}${animal}${number}`
}

// Expanded achievements system
const ACHIEVEMENTS = {
  // Starter achievements
  first_pack: { name: '–ü–µ—Ä–≤—ã–π –ø–∞–∫', description: '–û—Ç–∫—Ä–æ–π—Ç–µ —Å–≤–æ–π –ø–µ—Ä–≤—ã–π –ø–∞–∫', reward: 50, icon: 'üéÅ' },
  welcome: { name: '–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å', description: '–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å –≤ Pok√©Portal', reward: 100, icon: 'üëã' },
  
  // Collection achievements
  collector_10: { name: '–ö–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä I', description: '–°–æ–±–µ—Ä–∏—Ç–µ 10 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–∫–µ–º–æ–Ω–æ–≤', reward: 100, icon: 'üèÜ' },
  collector_25: { name: '–ö–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä II', description: '–°–æ–±–µ—Ä–∏—Ç–µ 25 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–∫–µ–º–æ–Ω–æ–≤', reward: 200, icon: 'üèÜ' },
  collector_50: { name: '–ö–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä III', description: '–°–æ–±–µ—Ä–∏—Ç–µ 50 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–∫–µ–º–æ–Ω–æ–≤', reward: 500, icon: 'üèÜ' },
  collector_100: { name: '–ö–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä IV', description: '–°–æ–±–µ—Ä–∏—Ç–µ 100 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–∫–µ–º–æ–Ω–æ–≤', reward: 1000, icon: 'üèÜ' },
  collector_200: { name: '–ú–∞—Å—Ç–µ—Ä –∫–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä', description: '–°–æ–±–µ—Ä–∏—Ç–µ 200 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–∫–µ–º–æ–Ω–æ–≤', reward: 2000, icon: 'üëë' },
  
  // Rarity achievements
  common_master: { name: '–û–±—ã—á–Ω—ã–π –∫–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä', description: '–ü–æ–ª—É—á–∏—Ç–µ 50 –æ–±—ã—á–Ω—ã—Ö –ø–æ–∫–µ–º–æ–Ω–æ–≤', reward: 150, icon: '‚ö™' },
  uncommon_master: { name: '–ù–µ–æ–±—ã—á–Ω—ã–π –∫–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä', description: '–ü–æ–ª—É—á–∏—Ç–µ 25 –Ω–µ–æ–±—ã—á–Ω—ã—Ö –ø–æ–∫–µ–º–æ–Ω–æ–≤', reward: 200, icon: 'üü¢' },
  rare_master: { name: '–†–µ–¥–∫–∏–π –∫–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä', description: '–ü–æ–ª—É—á–∏—Ç–µ 15 —Ä–µ–¥–∫–∏—Ö –ø–æ–∫–µ–º–æ–Ω–æ–≤', reward: 300, icon: 'üîµ' },
  epic_master: { name: '–≠–ø–∏—á–µ—Å–∫–∏–π –∫–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä', description: '–ü–æ–ª—É—á–∏—Ç–µ 10 —ç–ø–∏—á–µ—Å–∫–∏—Ö –ø–æ–∫–µ–º–æ–Ω–æ–≤', reward: 500, icon: 'üü£' },
  legendary_master: { name: '–õ–µ–≥–µ–Ω–¥–∞—Ä–Ω—ã–π –∫–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä', description: '–ü–æ–ª—É—á–∏—Ç–µ 5 –ª–µ–≥–µ–Ω–¥–∞—Ä–Ω—ã—Ö –ø–æ–∫–µ–º–æ–Ω–æ–≤', reward: 1000, icon: 'üü°' },
  
  // Pack opening achievements
  pack_opener_10: { name: '–ù–∞—á–∏–Ω–∞—é—â–∏–π –æ—Ç–∫—Ä—ã–≤–∞—Ç–µ–ª—å', description: '–û—Ç–∫—Ä–æ–π—Ç–µ 10 –ø–∞–∫–æ–≤', reward: 200, icon: 'üì¶' },
  pack_opener_50: { name: '–û–ø—ã—Ç–Ω—ã–π –æ—Ç–∫—Ä—ã–≤–∞—Ç–µ–ª—å', description: '–û—Ç–∫—Ä–æ–π—Ç–µ 50 –ø–∞–∫–æ–≤', reward: 500, icon: 'üì¶' },
  pack_opener_100: { name: '–ú–∞—Å—Ç–µ—Ä –æ—Ç–∫—Ä—ã–≤–∞–Ω–∏—è', description: '–û—Ç–∫—Ä–æ–π—Ç–µ 100 –ø–∞–∫–æ–≤', reward: 1000, icon: 'üì¶' },
  
  // Trading achievements
  trader: { name: '–¢–æ—Ä–≥–æ–≤–µ—Ü', description: '–ü—Ä–æ–¥–∞–π—Ç–µ –ø–µ—Ä–≤–æ–≥–æ –ø–æ–∫–µ–º–æ–Ω–∞ –Ω–∞ –∞—É–∫—Ü–∏–æ–Ω–µ', reward: 75, icon: 'üí∞' },
  successful_trader: { name: '–£—Å–ø–µ—à–Ω—ã–π —Ç–æ—Ä–≥–æ–≤–µ—Ü', description: '–ü—Ä–æ–¥–∞–π—Ç–µ 10 –ø–æ–∫–µ–º–æ–Ω–æ–≤ –Ω–∞ –∞—É–∫—Ü–∏–æ–Ω–µ', reward: 300, icon: 'üí∞' },
  trading_master: { name: '–ú–∞—Å—Ç–µ—Ä —Ç–æ—Ä–≥–æ–≤–ª–∏', description: '–ü—Ä–æ–¥–∞–π—Ç–µ 50 –ø–æ–∫–µ–º–æ–Ω–æ–≤ –Ω–∞ –∞—É–∫—Ü–∏–æ–Ω–µ', reward: 1000, icon: 'üí∞' },
  
  // Wealth achievements
  rich: { name: '–ë–æ–≥–∞—á', description: '–ù–∞–∫–æ–ø–∏—Ç–µ 1000 Pok√©Coins', reward: 200, icon: 'üíé' },
  wealthy: { name: '–°–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω—ã–π', description: '–ù–∞–∫–æ–ø–∏—Ç–µ 5000 Pok√©Coins', reward: 500, icon: 'üíé' },
  millionaire: { name: '–ú–∏–ª–ª–∏–æ–Ω–µ—Ä', description: '–ù–∞–∫–æ–ø–∏—Ç–µ 10000 Pok√©Coins', reward: 1000, icon: 'üíé' },
  
  // Luck achievements
  lucky: { name: '–í–µ–∑—É–Ω—á–∏–∫', description: '–ü–æ–ª—É—á–∏—Ç–µ –ª–µ–≥–µ–Ω–¥–∞—Ä–Ω–æ–≥–æ –ø–æ–∫–µ–º–æ–Ω–∞', reward: 300, icon: '‚≠ê' },
  super_lucky: { name: '–°—É–ø–µ—Ä –≤–µ–∑—É–Ω—á–∏–∫', description: '–ü–æ–ª—É—á–∏—Ç–µ –ª–µ–≥–µ–Ω–¥–∞—Ä–Ω–æ–≥–æ –ø–æ–∫–µ–º–æ–Ω–∞ –∏–∑ –ø–µ—Ä–≤—ã—Ö 10 –ø–∞–∫–æ–≤', reward: 500, icon: '‚≠ê' },
  
  // Type collection achievements
  fire_collector: { name: '–û–≥–Ω–µ–Ω–Ω—ã–π –∫–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä', description: '–°–æ–±–µ—Ä–∏—Ç–µ 20 –æ–≥–Ω–µ–Ω–Ω—ã—Ö –ø–æ–∫–µ–º–æ–Ω–æ–≤', reward: 250, icon: 'üî•' },
  water_collector: { name: '–í–æ–¥–Ω—ã–π –∫–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä', description: '–°–æ–±–µ—Ä–∏—Ç–µ 20 –≤–æ–¥–Ω—ã—Ö –ø–æ–∫–µ–º–æ–Ω–æ–≤', reward: 250, icon: 'üíß' },
  grass_collector: { name: '–¢—Ä–∞–≤—è–Ω–æ–π –∫–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä', description: '–°–æ–±–µ—Ä–∏—Ç–µ 20 —Ç—Ä–∞–≤—è–Ω—ã—Ö –ø–æ–∫–µ–º–æ–Ω–æ–≤', reward: 250, icon: 'üåø' },
  electric_collector: { name: '–≠–ª–µ–∫—Ç—Ä–∏—á–µ—Å–∫–∏–π –∫–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä', description: '–°–æ–±–µ—Ä–∏—Ç–µ 20 —ç–ª–µ–∫—Ç—Ä–∏—á–µ—Å–∫–∏—Ö –ø–æ–∫–µ–º–æ–Ω–æ–≤', reward: 250, icon: '‚ö°' },
  
  // Level achievements
  level_10: { name: '–ù–æ–≤–∏—á–æ–∫', description: '–î–æ—Å—Ç–∏–≥–Ω–∏—Ç–µ 10 —É—Ä–æ–≤–Ω—è', reward: 300, icon: 'üéØ' },
  level_25: { name: '–û–ø—ã—Ç–Ω—ã–π —Ç—Ä–µ–Ω–µ—Ä', description: '–î–æ—Å—Ç–∏–≥–Ω–∏—Ç–µ 25 —É—Ä–æ–≤–Ω—è', reward: 500, icon: 'üéØ' },
  level_50: { name: '–ú–∞—Å—Ç–µ—Ä —Ç—Ä–µ–Ω–µ—Ä', description: '–î–æ—Å—Ç–∏–≥–Ω–∏—Ç–µ 50 —É—Ä–æ–≤–Ω—è', reward: 1000, icon: 'üéØ' },
  level_75: { name: '–≠–ª–∏—Ç–Ω—ã–π —Ç—Ä–µ–Ω–µ—Ä', description: '–î–æ—Å—Ç–∏–≥–Ω–∏—Ç–µ 75 —É—Ä–æ–≤–Ω—è', reward: 1500, icon: 'üéØ' },
  level_100: { name: '–ß–µ–º–ø–∏–æ–Ω', description: '–î–æ—Å—Ç–∏–≥–Ω–∏—Ç–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ 100 —É—Ä–æ–≤–Ω—è', reward: 2500, icon: 'üëë' },
  
  // Special achievements
  speedrun: { name: '–°–ø–∏–¥—Ä–∞–Ω–Ω–µ—Ä', description: '–°–æ–±–µ—Ä–∏—Ç–µ 50 –ø–æ–∫–µ–º–æ–Ω–æ–≤ –∑–∞ –ø–µ—Ä–≤—ã–π –¥–µ–Ω—å', reward: 1000, icon: '‚ö°' },
  patient: { name: '–¢–µ—Ä–ø–µ–ª–∏–≤—ã–π', description: '–ò–≥—Ä–∞–π—Ç–µ 30 –¥–Ω–µ–π –ø–æ–¥—Ä—è–¥', reward: 1500, icon: 'üìÖ' },
  diversity: { name: '–†–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏–µ', description: '–°–æ–±–µ—Ä–∏—Ç–µ –ø–æ–∫–µ–º–æ–Ω–æ–≤ –≤—Å–µ—Ö 18 —Ç–∏–ø–æ–≤', reward: 2000, icon: 'üåà' }
}

// Quests system
const DAILY_QUESTS = {
  open_pack: { name: '–û—Ç–∫—Ä—ã–≤–∞—Ç–µ–ª—å', description: '–û—Ç–∫—Ä–æ–π—Ç–µ 1 –ø–∞–∫', reward: 25, target: 1, icon: 'üì¶' },
  collect_cards: { name: '–°–æ–±–∏—Ä–∞—Ç–µ–ª—å', description: '–ü–æ–ª—É—á–∏—Ç–µ 3 –Ω–æ–≤—ã–µ –∫–∞—Ä—Ç–æ—á–∫–∏', reward: 50, target: 3, icon: 'üÉè' },
  trade_pokemon: { name: '–¢–æ—Ä–≥–æ–≤–µ—Ü –¥–Ω—è', description: '–ü—Ä–æ–¥–∞–π—Ç–µ 1 –ø–æ–∫–µ–º–æ–Ω–∞', reward: 40, target: 1, icon: 'ü§ù' }
}

// Pokemon types with icons and colors
const POKEMON_TYPES = {
  normal: { icon: '‚ö™', color: '#A8A878' },
  fire: { icon: 'üî•', color: '#F08030' },
  water: { icon: 'üíß', color: '#6890F0' },
  electric: { icon: '‚ö°', color: '#F8D030' },
  grass: { icon: 'üåø', color: '#78C850' },
  ice: { icon: '‚ùÑÔ∏è', color: '#98D8D8' },
  fighting: { icon: 'üëä', color: '#C03028' },
  poison: { icon: '‚ò†Ô∏è', color: '#A040A0' },
  ground: { icon: 'üåç', color: '#E0C068' },
  flying: { icon: 'ü™∂', color: '#A890F0' },
  psychic: { icon: 'üîÆ', color: '#F85888' },
  bug: { icon: 'üêõ', color: '#A8B820' },
  rock: { icon: 'ü™®', color: '#B8A038' },
  ghost: { icon: 'üëª', color: '#705898' },
  dragon: { icon: 'üêâ', color: '#7038F8' },
  dark: { icon: 'üåô', color: '#705848' },
  steel: { icon: '‚öôÔ∏è', color: '#B8B8D0' },
  fairy: { icon: 'üßö', color: '#EE99AC' }
}

// Achievement checking function
async function checkAchievements(userId: string, trigger: string, data: any) {
  try {
    const userAchievements = await kv.get(`achievements_${userId}`) || {}
    const userProfile = await kv.get(`user_${userId}`)
    const collection = await kv.get(`collection_${userId}`) || {}
    
    let rewardCoins = 0

    // Check various achievement triggers
    if (trigger === 'signup') {
      if (!userAchievements.welcome?.completed) {
        userAchievements.welcome = { completed: true, date: new Date().toISOString() }
        rewardCoins += ACHIEVEMENTS.welcome.reward
      }
    }

    if (trigger === 'pack_opened') {
      // Check first pack achievement
      if (!userAchievements.first_pack?.completed) {
        userAchievements.first_pack = { completed: true, date: new Date().toISOString() }
        rewardCoins += ACHIEVEMENTS.first_pack.reward
      }
      
      // Check collection size achievements
      const uniqueCount = Object.keys(collection).length
      if (uniqueCount >= 10 && !userAchievements.collector_10?.completed) {
        userAchievements.collector_10 = { completed: true, date: new Date().toISOString() }
        rewardCoins += ACHIEVEMENTS.collector_10.reward
      }
      if (uniqueCount >= 25 && !userAchievements.collector_25?.completed) {
        userAchievements.collector_25 = { completed: true, date: new Date().toISOString() }
        rewardCoins += ACHIEVEMENTS.collector_25.reward
      }
      if (uniqueCount >= 50 && !userAchievements.collector_50?.completed) {
        userAchievements.collector_50 = { completed: true, date: new Date().toISOString() }
        rewardCoins += ACHIEVEMENTS.collector_50.reward
      }
      if (uniqueCount >= 100 && !userAchievements.collector_100?.completed) {
        userAchievements.collector_100 = { completed: true, date: new Date().toISOString() }
        rewardCoins += ACHIEVEMENTS.collector_100.reward
      }
      if (uniqueCount >= 200 && !userAchievements.collector_200?.completed) {
        userAchievements.collector_200 = { completed: true, date: new Date().toISOString() }
        rewardCoins += ACHIEVEMENTS.collector_200.reward
      }

      // Check legendary achievement
      if (data.cards) {
        for (const card of data.cards) {
          if (card.rarity === 'legendary' && !userAchievements.lucky?.completed) {
            userAchievements.lucky = { completed: true, date: new Date().toISOString() }
            rewardCoins += ACHIEVEMENTS.lucky.reward
            break
          }
        }
      }
    }

    if (trigger === 'level_up') {
      const level = data.level
      if (level >= 10 && !userAchievements.level_10?.completed) {
        userAchievements.level_10 = { completed: true, date: new Date().toISOString() }
        rewardCoins += ACHIEVEMENTS.level_10.reward
      }
      if (level >= 25 && !userAchievements.level_25?.completed) {
        userAchievements.level_25 = { completed: true, date: new Date().toISOString() }
        rewardCoins += ACHIEVEMENTS.level_25.reward
      }
      if (level >= 50 && !userAchievements.level_50?.completed) {
        userAchievements.level_50 = { completed: true, date: new Date().toISOString() }
        rewardCoins += ACHIEVEMENTS.level_50.reward
      }
      if (level >= 75 && !userAchievements.level_75?.completed) {
        userAchievements.level_75 = { completed: true, date: new Date().toISOString() }
        rewardCoins += ACHIEVEMENTS.level_75.reward
      }
      if (level >= 100 && !userAchievements.level_100?.completed) {
        userAchievements.level_100 = { completed: true, date: new Date().toISOString() }
        rewardCoins += ACHIEVEMENTS.level_100.reward
      }
    }

    if (trigger === 'coins_updated') {
      const coins = data.poke_coins
      if (coins >= 1000 && !userAchievements.rich?.completed) {
        userAchievements.rich = { completed: true, date: new Date().toISOString() }
        rewardCoins += ACHIEVEMENTS.rich.reward
      }
      if (coins >= 5000 && !userAchievements.wealthy?.completed) {
        userAchievements.wealthy = { completed: true, date: new Date().toISOString() }
        rewardCoins += ACHIEVEMENTS.wealthy.reward
      }
      if (coins >= 10000 && !userAchievements.millionaire?.completed) {
        userAchievements.millionaire = { completed: true, date: new Date().toISOString() }
        rewardCoins += ACHIEVEMENTS.millionaire.reward
      }
    }

    if (trigger === 'auction_sale') {
      if (!userAchievements.trader?.completed) {
        userAchievements.trader = { completed: true, date: new Date().toISOString() }
        rewardCoins += ACHIEVEMENTS.trader.reward
      }
    }

    // Save achievements and add reward coins
    await kv.set(`achievements_${userId}`, userAchievements)
    
    if (rewardCoins > 0 && userProfile) {
      userProfile.poke_coins += rewardCoins
      await kv.set(`user_${userId}`, userProfile)
    }

    return rewardCoins
  } catch (error) {
    console.log('Check achievements error:', error)
    return 0
  }
}

// User signup
app.post('/make-server-eca1b907/signup', async (c) => {
  try {
    const { email, password, name } = await c.req.json()
    
    const { data, error } = await supabase.auth.admin.createUser({
      email,
      password,
      user_metadata: { name, role: 'user' },
      // Automatically confirm the user's email since an email server hasn't been configured.
      email_confirm: true
    })

    if (error) {
      console.log('Signup error:', error)
      return c.json({ error: error.message }, 400)
    }

    // Generate nice user ID
    let niceId = generateNiceUserId()
    let existingUser = await kv.get(`user_by_nice_id_${niceId}`)
    while (existingUser) {
      niceId = generateNiceUserId()
      existingUser = await kv.get(`user_by_nice_id_${niceId}`)
    }

    // Initialize user data
    const userData = {
      id: data.user.id,
      nice_id: niceId,
      email,
      name,
      role: 'user',
      poke_coins: 500,
      created_at: new Date().toISOString()
    }

    await kv.set(`user_${data.user.id}`, userData)
    await kv.set(`user_by_nice_id_${niceId}`, data.user.id)
    await kv.set(`collection_${data.user.id}`, {})
    await kv.set(`achievements_${data.user.id}`, {})
    await kv.set(`quests_${data.user.id}`, {})
    await kv.set(`level_${data.user.id}`, { experience: 0, level: 1 })
    await kv.set(`level_rewards_${data.user.id}`, [])
    
    // Give welcome achievement
    await checkAchievements(data.user.id, 'signup', {})

    return c.json({ user: data.user })
  } catch (error) {
    console.log('Signup error:', error)
    return c.json({ error: 'Internal server error' }, 500)
  }
})

// Get user profile
app.get('/make-server-eca1b907/profile', async (c) => {
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1]
    const { data: { user }, error } = await supabase.auth.getUser(accessToken)
    
    if (!user?.id) {
      return c.json({ error: 'Unauthorized' }, 401)
    }

    const userProfile = await kv.get(`user_${user.id}`)
    return c.json(userProfile)
  } catch (error) {
    console.log('Profile error:', error)
    return c.json({ error: 'Internal server error' }, 500)
  }
})

// Get pokemon data
app.get('/make-server-eca1b907/pokemon', async (c) => {
  try {
    const pokemonData = await kv.get('pokemon_data') || []
    return c.json(pokemonData)
  } catch (error) {
    console.log('Pokemon data error:', error)
    return c.json({ error: 'Internal server error' }, 500)
  }
})

// Get user collection
app.get('/make-server-eca1b907/collection', async (c) => {
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1]
    const { data: { user }, error } = await supabase.auth.getUser(accessToken)
    
    if (!user?.id) {
      return c.json({ error: 'Unauthorized' }, 401)
    }

    const collection = await kv.get(`collection_${user.id}`) || {}
    return c.json(collection)
  } catch (error) {
    console.log('Collection error:', error)
    return c.json({ error: 'Internal server error' }, 500)
  }
})

// Get active auctions
app.get('/make-server-eca1b907/auctions/active', async (c) => {
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1]
    const { data: { user }, error } = await supabase.auth.getUser(accessToken)
    
    if (!user?.id) {
      return c.json({ error: 'Unauthorized' }, 401)
    }

    const auctions = await kv.get('auctions') || []
    const now = new Date()
    
    // Filter active auctions (not expired and not sold)
    const activeAuctions = auctions.filter((auction: any) => {
      const expiresAt = new Date(auction.expiresAt)
      return auction.status === 'active' && expiresAt > now
    })

    // Add seller nice_id to each auction
    const auctionsWithSellerInfo = await Promise.all(
      activeAuctions.map(async (auction: any) => {
        const sellerProfile = await kv.get(`user_${auction.sellerId}`)
        return {
          ...auction,
          sellerNiceId: sellerProfile?.nice_id || 'Unknown'
        }
      })
    )

    return c.json(auctionsWithSellerInfo)
  } catch (error) {
    console.log('Get active auctions error:', error)
    return c.json({ error: 'Internal server error' }, 500)
  }
})

// Get user's auctions
app.get('/make-server-eca1b907/auctions/my', async (c) => {
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1]
    const { data: { user }, error } = await supabase.auth.getUser(accessToken)
    
    if (!user?.id) {
      return c.json({ error: 'Unauthorized' }, 401)
    }

    const auctions = await kv.get('auctions') || []
    
    // Filter auctions by current user
    const userAuctions = auctions.filter((auction: any) => auction.sellerId === user.id)

    return c.json(userAuctions)
  } catch (error) {
    console.log('Get user auctions error:', error)
    return c.json({ error: 'Internal server error' }, 500)
  }
})

// Create auction
app.post('/make-server-eca1b907/auctions/create', async (c) => {
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1]
    const { data: { user }, error } = await supabase.auth.getUser(accessToken)
    
    if (!user?.id) {
      return c.json({ error: 'Unauthorized' }, 401)
    }

    const { pokemonId, startingPrice, duration } = await c.req.json()
    
    // Validate inputs
    if (!pokemonId || !startingPrice || !duration) {
      return c.json({ error: 'Missing required fields' }, 400)
    }

    if (startingPrice <= 0) {
      return c.json({ error: 'Starting price must be positive' }, 400)
    }

    // Check if user owns this pokemon
    const collection = await kv.get(`collection_${user.id}`) || {}
    if (!collection[pokemonId] || collection[pokemonId] <= 0) {
      return c.json({ error: 'You do not own this Pokemon' }, 400)
    }

    // Remove one pokemon from collection
    collection[pokemonId] -= 1
    if (collection[pokemonId] === 0) {
      delete collection[pokemonId]
    }
    await kv.set(`collection_${user.id}`, collection)

    // Calculate expiration time
    const expiresAt = new Date()
    expiresAt.setHours(expiresAt.getHours() + duration)

    // Create auction
    const auctions = await kv.get('auctions') || []
    const auctionId = `auction_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    
    const newAuction = {
      id: auctionId,
      sellerId: user.id,
      pokemonId: parseInt(pokemonId),
      startingPrice: parseInt(startingPrice),
      currentPrice: parseInt(startingPrice),
      highestBidderId: null,
      status: 'active',
      createdAt: new Date().toISOString(),
      expiresAt: expiresAt.toISOString(),
      bids: []
    }

    auctions.push(newAuction)
    await kv.set('auctions', auctions)

    // Check achievement for first auction
    await checkAchievements(user.id, 'auction_sale', {})

    return c.json({ auction: newAuction })
  } catch (error) {
    console.log('Create auction error:', error)
    return c.json({ error: 'Internal server error' }, 500)
  }
})

// Place bid on auction
app.post('/make-server-eca1b907/auctions/bid', async (c) => {
  try {
    const accessToken = c.req.header('Authorization')?.split(' ')[1]
    const { data: { user }, error } = await supabase.auth.getUser(accessToken)
    
    if (!user?.id) {
      return c.json({ error: 'Unauthorized' }, 401)
    }

    const { auctionId, bidAmount } = await c.req.json()
    
    // Validate inputs
    if (!auctionId || !bidAmount || bidAmount <= 0) {
      return c.json({ error: 'Invalid bid parameters' }, 400)
    }

    // Get auctions
    const auctions = await kv.get('auctions') || []
    const auctionIndex = auctions.findIndex((a: any) => a.id === auctionId)
    
    if (auctionIndex === -1) {
      return c.json({ error: 'Auction not found' }, 404)
    }

    const auction = auctions[auctionIndex]

    // Check if auction is still active
    const now = new Date()
    const expiresAt = new Date(auction.expiresAt)
    
    if (auction.status !== 'active' || expiresAt <= now) {
      return c.json({ error: 'Auction is no longer active' }, 400)
    }

    // Check if user is not the seller
    if (auction.sellerId === user.id) {
      return c.json({ error: 'Cannot bid on own auction' }, 400)
    }

    // Check if bid is higher than current price
    if (bidAmount <= auction.currentPrice) {
      return c.json({ error: 'Bid must be higher than current price' }, 400)
    }

    // Check if user has enough coins
    const userProfile = await kv.get(`user_${user.id}`)
    if (userProfile.poke_coins < bidAmount) {
      return c.json({ error: 'Insufficient coins' }, 400)
    }

    // Return coins to previous highest bidder if exists
    if (auction.highestBidderId && auction.highestBidderId !== user.id) {
      const previousBidder = await kv.get(`user_${auction.highestBidderId}`)
      if (previousBidder) {
        previousBidder.poke_coins += auction.currentPrice
        await kv.set(`user_${auction.highestBidderId}`, previousBidder)
      }
    }

    // Deduct coins from current bidder
    userProfile.poke_coins -= bidAmount
    await kv.set(`user_${user.id}`, userProfile)

    // Update auction
    auction.currentPrice = bidAmount
    auction.highestBidderId = user.id
    auction.bids.push({
      bidderId: user.id,
      amount: bidAmount,
      timestamp: new Date().toISOString()
    })

    // If this is a "buy now" scenario (significantly higher bid), end auction immediately
    const buyNowThreshold = auction.startingPrice * 3
    if (bidAmount >= buyNowThreshold) {
      // Complete the auction immediately
      auction.status = 'sold'
      
      // Transfer pokemon to buyer
      const buyerCollection = await kv.get(`collection_${user.id}`) || {}
      buyerCollection[auction.pokemonId] = (buyerCollection[auction.pokemonId] || 0) + 1
      await kv.set(`collection_${user.id}`, buyerCollection)

      // Give coins to seller
      const seller = await kv.get(`user_${auction.sellerId}`)
      if (seller) {
        seller.poke_coins += bidAmount
        await kv.set(`user_${auction.sellerId}`, seller)
      }
    }

    auctions[auctionIndex] = auction
    await kv.set('auctions', auctions)

    return c.json({ success: true, auction })
  } catch (error) {
    console.log('Place bid error:', error)
    return c.json({ error: 'Internal server error' }, 500)
  }
})

Deno.serve(app.fetch)